## Server with Rocket.rs
This post is a continuation of a series on setting up a raspberry pi for this site. In the [previous post](http://localhost:8000/blog/posts/2020-11-06-3.md), I made a simple blog page for rendering Markdown posts.

I said in an earlier post, that I'll need a server in future. Lets set it up now, even though for now it will mostly be serving static files for the blog site. I like [rocket.rs](https://rocket.rs/), an ergonomic web server framework for [Rust](https://www.rust-lang.org/). There will be no rust evangelism here though. I like it, and I'll use it here. Other people have described the pros and cons better than me.

I don't need much right now, a `/health` endpoint for kubernetes readyness check, and the ability to serve static files. Assuming ui files are in ./ui/ , this looks like it should be enough:

```rust
use rocket;
use rocket::{get, routes};
use rocket_contrib::serve::StaticFiles;

#[get("/health")]
pub fn health() -> &'static str {
    "OK"
}

fn main() {
    rocket::ignite()
        .mount("/", StaticFiles::from("/ui"))
        .mount("/", routes![health])
        .launch();
}
```

But not really, this won't work.

Firstly, I'd like to have routing in the blog site, for things like permalinks, separate links for experiments etc. I already have a nice hacky preact based setup going, might as well use preact router for routing. As anyone familiar with the modern web "router"s knows, that means I'll have to do some URL re-writing.

Second reason is: I don't want the server to touch the filesystem if at all possible. It is easy to include a directory in the compiled binary, and with some code, I should be able to serve files from memory, and have an equivalent of URL re-writing.

The [include_dir](https://crates.io/crates/include_dir) crate will embed an entire directory in the binary, and access files and folders in it, similar to a real filesystem. I can plugin it in, in a similar way to `rocket_contrib::serve::StaticFiles` by implementing some traits like this (don't judge me bro):

```rust
//...snip...
.mount("/", InMemDir {})
//...snip...

static UI_DIR: Dir = include_dir!("./ui");

#[derive(Clone)]
pub struct InMemDir {}

pub struct InMemFile {
    path: String,
    contents: Vec<u8>,
}

impl InMemFile {
    pub fn from_file(f: File) -> Self {
        let c = f.contents();
        let mut c2: Vec<u8> = vec![];
        for v in c {
            c2.push(v.clone());
        }
        InMemFile {
            path: f.path.into(),
            contents: c2,
        }
    }
}

impl<'r> Responder<'r, 'r> for InMemFile {
    fn respond_to(self, _: &'r Request<'_>) -> rocket::response::Result<'r> {
        let mut mime: ContentType = ContentType::new("application", "octet-stream");

        if self.path.ends_with("html") {
            mime = ContentType::new("text", "html");
        } else if self.path.ends_with("js") {
            mime = ContentType::new("text", "javascript");
        } else if self.path.ends_with("css") {
            mime = ContentType::new("text", "css");
        }
        Response::build()
            .status(Status::new(200, "OK"))
            .streamed_body(Cursor::new(self.contents))
            .header(mime)
            .ok()
    }
}

impl Into<Vec<Route>> for InMemDir {
    fn into(self) -> Vec<Route> {
        let non_index = Route::ranked(30, Method::Get, "/<path..>", self.clone());
        let index = Route::ranked(30, Method::Get, "/", self);
        vec![index, non_index]
    }
}

#[rocket::async_trait]
impl Handler for InMemDir {
    async fn handle<'r, 's: 'r>(
        &'s self,
        req: &'r Request<'_>,
        data: rocket::data::Data,
    ) -> Outcome<'r> {
        let path = req
            .get_segments::<rocket::http::uri::Segments<'_>>(0)
            .and_then(|res| res.ok())
            .and_then(|segments| segments.into_path_buf(false).ok());

        match path {
            Some(p) => {
                let path = p.clone().into_os_string().into_string().unwrap();
                let is_dir = p.is_dir() || UI_DIR.get_dir(&path).is_some();

                if (is_dir) {
                    if let Some(dir) = UI_DIR.get_dir(path) {
                        let mut res: String = "<div>".into();
                        let files = dir.files();
                        for f in files {
                            res = res + "\n<a href=\"" + f.path + "\" />";
                        }
                        res = res + "</div>";
                        return Outcome::from_or_forward(req, data, res);
                    }

                    return Outcome::forward(data);
                }

                let maybe_file = UI_DIR.get_file(path);

                match maybe_file {
                    Some(f) => Outcome::from_or_forward(req, data, InMemFile::from_file(f)),
                    None => match UI_DIR.get_file("index.html") {
                        Some(f) => Outcome::from_or_forward(req, data, InMemFile::from_file(f)),
                        None => Outcome::forward(data),
                    },
                }
            }
            None => match UI_DIR.get_file("index.html") {
                Some(f) => Outcome::from_or_forward(req, data, InMemFile::from_file(f)),
                None => Outcome::forward(data),
            },
        }
    }
}
```

So now I have a way to serve static files, and it plays nice with preact-router.

Let's package it up into a docker conatiner image:
```docker
FROM ubuntu:20.04
RUN mkdir /app
WORKDIR /app
COPY ./target/release/myapp /app/myapp
CMD ["/app/myapp"]
```

And let's also deploy it to kubernetes. Note the use of localhost:32000 registry, that was setup when I did `microk8s enable registry` during initial setup:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: prod
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: localhost:32000/nk/myapp:1.0.1
        imagePullPolicy: Always
        ports:
        - containerPort: 8000
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          periodSeconds: 30
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 2
        env:
          - name: RUST_BACKTRACE
            value: "1"
        resources:
          limits:
            cpu: 100m
            memory: 150Mi
          requests:
            cpu: 100m
            memory: 150Mi
---
kind: Service
apiVersion: v1
metadata:
  name: myapp
  namespace: prod
spec:
  type: ClusterIP
  selector:
    app: myapp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
    name: myapp
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: myapp
  namespace: prod
  annotations:
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
spec:
  rules:
  - host: "n-k.freeddns.org"
    http:
      paths:
      - path: /
        backend:
          serviceName: myapp
          servicePort: 80
```
I will add a script to build and deploy this to microk8s. This is run on the Pi by buildbot whenever I push a commit:
```bash
#!/bin/bash
set -eux
$HOME/.cargo/bin/cargo build --release -j $(($(nproc) / 2))
docker build -t localhost:32000/nk/myapp:1.0.1 .
docker push localhost:32000/nk/myapp:1.0.1
microk8s.kubectl apply -f ./k8s/all.yaml
microk8s.kubectl patch deployment myapp -p '{"spec":{"template":{"metadata":{"annotations":{"date":"'"$(date)"'"}}}}}' -n prod
```

I should also setup some templating and some way to sync the image tag between the script and yaml files, and I will...some day soon. I hear kustomize is getting popular for templating.

Did you notice `$HOME/.cargo/bin/cargo build --release -j $(($(nproc) / 2))` ? `$(($(nproc) / 2))` is a nice way to do simple arithmetic in bash. That line tells cargo to compile using half the cores available.

Once this setup works, I will be able to access the blog from raspberry pi's IP address. Its still missing couple of things. For one, its only accessible within my home. I don't need a site to read my own files, and wifey finds all this boring. How can I let other people access my raspberry? I can tell the home router to forward incoming connections on HTTP(S) ports to the pi's address. As long as I have a static DHCP reservation for the pi's mac address. Both of these should be available on most routers, a good resource to check is https://portforward.com/ , they have documents for many router models.

Even after static DHCP reservation and port-forwarding, I would need to give you my router's external IP address to view the blog, which is inconvenient, and it changes frequently. Enter DDNS, or Dynamic DNS. There are services which will maintain DNS records for you, often for free, and every time your router's IP changes, you can configure it to notify the service using a standard protocol. The service will then update the DNS records.

I registered with https://dynu.com and claimed https://n-k.freeddns.org . There are other providers, but I like dynu. Note that if you have a free account, you can only choose a subdomain of few available domains. For paid users, all services have an option of using a custom domain. DDNS configuration docs should also be available at https://portforward.com/ , if not, you can check your router's manual or the internet.

After this I had the blog accessible via https://n-k.freeddns.org but browsers would show a warning about the certificate. That is because I don't a certificate signd by a recognized certificate authority (CA). Enter [LetsEncypt](https://letsencrypt.org/). LetsEncrypt give anyone free certificates, as long as they control the domain they want a certificate for. Its very easy to setup in microk8s. 

Install components for requesting a certificate:
```bash
#!/bin/bash
set -eux
microk8s enable helm3 ingress
microk8s kubectl create namespace cert-manager
microk8s helm3 repo add jetstack https://charts.jetstack.io
microk8s helm3 repo update
microk8s helm3 install cert-manager jetstack/cert-manager \
  --namespace cert-manager --version v0.15.2 \
  --set installCRDs=true \
  --set ingressShim.defaultIssuerName=letsencrypt-production \
  --set ingressShim.defaultIssuerKind=ClusterIssuer \
  --set ingressShim.defaultIssuerGroup=cert-manager.io
```

And then update the ingress resource, like so:
```yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: myapp
  namespace: prod
  annotations:
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    kubernetes.io/tls-acme: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-production"
spec:
  tls:
  - hosts:
    - "n-k.freeddns.org"
    secretName: "myapp-tls"
  rules:
  - host: "n-k.freeddns.org"
    http:
      paths:
      - path: /
        backend:
          serviceName: myapp
          servicePort: 80
  - http:
      paths:
      - path: /
        backend:
          serviceName: myapp
          servicePort: 80
```
Thats it! In a few minutes, I'll have a public blog with a domain name and a TLS certificate!
