<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - equirectangular panorama</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      html,
      body {
        width: 100vw;
        height: 100vh;
        border: none;
        padding: 0;
        margin: 0;
      }
      #slider {
        position: absolute;
        bottom: 5px;
        width: 50%;
        left: 25%;
        height: 30px;
      }
      #slider label {
        display: block;
        background-color: gainsboro;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="container" style="width: 100%; height: 100%"></div>
    <div id="slider">
      <label id="updateBtn">Start/Stop gradient descent</label>
    </div>
    <script src="/vendor/three.js"></script>
    <script src="/vendor/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script>
      EXIF.enableXmp();
      let camera, scene, renderer;
      let radius = 171;
      let matches = [];
      const img_objects = [];
      const images = [];
      const imageWidth = 256;
      const imageHeight = 171;
      const horizontalFieldOfView = (73.7 * Math.PI) / 180;
      const verticalFieldOfView = (53.1 * Math.PI) / 180;

      let isUserInteracting = false,
        onPointerDownMouseX = 0,
        onPointerDownMouseY = 0,
        lon = 0,
        onPointerDownLon = 0,
        lat = -30,
        onPointerDownLat = 0,
        phi = 0,
        theta = 0;

      init();
      animate();

      function init() {
        const container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          1,
          1100
        );
        camera.target = new THREE.Vector3(0, 0, 0);

        scene = new THREE.Scene();

        const geometry = new THREE.SphereBufferGeometry(radius + 100, 60, 40);
        // invert the geometry on the x-axis so that all of the faces point inward
        geometry.scale(-1, 1, 1);

        // const texture = new THREE.TextureLoader().load("./sample.jpg");
        const material = new THREE.MeshBasicMaterial({
          wireframe: true,
          //   map: texture,
        });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 0, 0);
        scene.add(light);

        // add images
        for (var idx = 1; idx < 51; idx++) {
          const url = `./images/${idx}.jpg`;
          const img = new Image();
          $(img).on("load", function () {
            EXIF.getData(img, function () {
              const attrs =
                img.xmpdata["x:xmpmeta"]["rdf:RDF"]["rdf:Description"][
                  "@attributes"
                ];
              const yaw = parseFloat(attrs["drone-dji:GimbalYawDegree"]);
              const pitch = parseFloat(attrs["drone-dji:GimbalPitchDegree"]);
              const roll = parseFloat(attrs["drone-dji:FlightRollDegree"]);

              // console.log(roll);

              const { x, y, z } = computeLocation(yaw, pitch);

              const loader = new THREE.TextureLoader();
              loader.load(
                url,
                function (texture) {
                  const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    wireframe: false,
                  });
                  const planegeo = new THREE.PlaneBufferGeometry(
                    img.width,
                    img.height
                  );
                  // planegeo.scale(-1, 1, 1);
                  const plane = new THREE.Mesh(planegeo, material);
                  plane.material.side = THREE.DoubleSide;
                  plane.rotation.z = (roll * Math.PI) / 180;
                  plane.position.x = x;
                  plane.position.y = y;
                  plane.position.z = z;
                  plane.lookAt(0, 0, 0);
                  scene.add(plane);
                  images.push({ plane, yaw, pitch, roll });
                },
                function () {},
                function (err) {
                  console.log(err);
                }
              );
            });
          });
          img.src = url;
          img_objects.push(img);
        }

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize($(window).width(), $(window).height());
        container.appendChild(renderer.domElement);

        container.style.touchAction = "none";
        container.addEventListener("pointerdown", onPointerDown, false);

        document.addEventListener("wheel", onDocumentMouseWheel, false);

        document.addEventListener(
          "dragover",
          function (event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = "copy";
          },
          false
        );

        document.addEventListener(
          "dragenter",
          function () {
            document.body.style.opacity = 0.5;
          },
          false
        );

        document.addEventListener(
          "dragleave",
          function () {
            document.body.style.opacity = 1;
          },
          false
        );
        window.addEventListener("resize", onWindowResize, false);

        $("#updateBtn").on("click", function () {
          updateOnce();
        });

        // load matches
        fetch("./matches.json").then((res) => {
          res.json().then((data) => {
            matches = data;
          });
        });
      }

      function computeLocation(yaw, pitch) {
        const phi = THREE.MathUtils.degToRad(90 - pitch);
        const theta = THREE.MathUtils.degToRad(yaw);

        // create a plane at required position
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);

        return { x, y, z };
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onPointerDown(event) {
        if (event.isPrimary === false) return;

        isUserInteracting = true;

        onPointerDownMouseX = event.clientX;
        onPointerDownMouseY = event.clientY;

        onPointerDownLon = lon;
        onPointerDownLat = lat;

        document.addEventListener("pointermove", onPointerMove, false);
        document.addEventListener("pointerup", onPointerUp, false);
      }

      function onPointerMove(event) {
        if (event.isPrimary === false) return;

        lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
        lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
      }

      function onPointerUp() {
        if (event.isPrimary === false) return;

        isUserInteracting = false;

        document.removeEventListener("pointermove", onPointerMove);
        document.removeEventListener("pointerup", onPointerUp);
      }

      function onDocumentMouseWheel(event) {
        const fov = camera.fov + event.deltaY * 0.05;

        camera.fov = THREE.MathUtils.clamp(fov, 10, 75);

        camera.updateProjectionMatrix();
      }

      function animate() {
        requestAnimationFrame(animate);
        update();
      }

      function update() {
        if (isUserInteracting === false) {
          // lon += 0.1;
        }

        lat = Math.max(-85, Math.min(85, lat));
        phi = THREE.MathUtils.degToRad(90 - lat);
        theta = THREE.MathUtils.degToRad(lon);

        camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
        camera.target.y = 500 * Math.cos(phi);
        camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);

        camera.lookAt(camera.target);
        renderer.render(scene, camera);
      }

      function errorForMatch(i) {
        // ignoring roll for now
        const match = matches[i];
        const image1 = images[match.image1];
        const { yaw: yaw1, pitch: pitch1, roll: roll1 } = image1;
        const image2 = images[match.image2];
        const { yaw: yaw2, pitch: pitch2, roll: roll2 } = image1;

        const dx1 = match.position1.x - imageWidth / 2;
        const dy1 = match.position1.y - imageHeight / 2;
        const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        const angle1 = Math.atan(dy1 / dx1);
        const correctedX1 = imageWidth / 2 + dist1 * Math.sin(angle1 + roll1);
        const correctedY1 = imageHeight / 2 + dist1 * Math.cos(angle1 + roll1);

        const dx2 = match.position2.x - imageWidth / 2;
        const dy2 = match.position2.y - imageHeight / 2;
        const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        const angle2 = Math.atan(dy2 / dx2);
        const correctedX2 = imageWidth / 2 + dist1 * Math.sin(angle2 + roll2);
        const correctedY2 = imageHeight / 2 + dist1 * Math.cos(angle2 + roll2);

        const predictedYaw1 =
          image1.yaw +
          (correctedX1 - imageWidth / 2) * (horizontalFieldOfView / imageWidth);
        const predictedPitch1 =
          image1.pitch +
          (correctedY1 - imageHeight / 2) * (verticalFieldOfView / imageHeight);

        const predictedYaw2 =
          image2.yaw +
          (correctedX2 - imageWidth / 2) * (horizontalFieldOfView / imageWidth);
        const predictedPitch2 =
          image2.pitch +
          (correctedY2 - imageHeight / 2) * (verticalFieldOfView / imageHeight);

        return (
          Math.abs(predictedYaw1 - predictedYaw2) +
          Math.abs(predictedPitch1 - predictedPitch2)
        );
      }

      function error() {
        let error = 0;
        for (let i = 0; i < matches.length; i++) {
          error += errorForMatch(i);
        }
        return error;
      }

      const delta = 0.0001;
      // const numIterations = 10;
      function updateImage(i) {
        // update yaw
        const orig = images[i];
        let copy = { ...orig };
        copy.yaw -= delta / 2;
        images[i] = copy;
        let error1 = error();
        copy.yaw += delta;
        images[i] = copy;
        let error2 = error();
        images[i] = orig;

        let grad = (error2 - error1) / delta; // d(error)/d(yaw(i))
        let correction = grad * delta;
        if (correction != NaN && correction != Infinity) {
          // console.log(`updating image[${i}].yaw by ${correction}`);
          images[i].yaw -= correction;
        }

        // update pitch
        copy = { ...orig };
        copy.pitch -= delta / 2;
        images[i] = copy;
        error1 = error();
        copy.pitch += delta;
        images[i] = copy;
        error2 = error();
        images[i] = orig;

        grad = (error2 - error1) / delta; // d(error)/d(pitch(i))
        correction = grad * delta;
        if (correction != NaN && correction != Infinity) {
          // console.log(`updating image[${i}].pitch by ${correction}`);
          images[i].pitch -= correction;
        }

        // update roll
        copy = { ...orig };
        copy.roll -= delta / 2;
        images[i] = copy;
        error1 = error();
        copy.roll += delta;
        images[i] = copy;
        error2 = error();
        images[i] = orig;

        grad = (error2 - error1) / delta; // d(error)/d(roll(i))
        correction = grad * delta;
        if (correction != NaN && correction != Infinity) {
          // console.log(`updating image[${i}].roll by ${correction}`);
          images[i].roll -= correction;
        }
      }

      let running = false;
      let iterations = 0;
      function updateOnce() {
        if (!running) {
          const fn = () => {
            for (let i = 0; i < images.length; i++) {
              updateImage(i);
            }
            updatePlanes();
            iterations++;
            console.log(`Finished update iteration ${iterations}. Error: ${error()}`);
            if (running) {
              window.setTimeout(fn, 500);
            }
          };
          running = true;
          window.setTimeout(fn, 500);
        } else {
          running = false;
        }
      }

      function updatePlanes() {
        for (const p of images) {
          const { plane, yaw, pitch, roll } = p;
          const { x, y, z } = computeLocation(yaw, pitch);
          plane.rotation.z = (roll * Math.PI) / 180;
          plane.position.x = x;
          plane.position.y = y;
          plane.position.z = z;
          plane.lookAt(0, 0, 0);
        }
      }
    </script>
  </body>
</html>
